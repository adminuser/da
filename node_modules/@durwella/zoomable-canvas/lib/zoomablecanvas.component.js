"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular/core");
class ZoomableCanvasComponent {
    constructor() {
        this.topChange = new core_1.EventEmitter();
        this.bottomChange = new core_1.EventEmitter();
        this.leftChange = new core_1.EventEmitter();
        this.rightChange = new core_1.EventEmitter();
        this.zoomLevelChange = new core_1.EventEmitter();
        this.centerXChange = new core_1.EventEmitter();
        this.centerYChange = new core_1.EventEmitter();
        this.canvasWidthChange = new core_1.EventEmitter();
        this.canvasHeightChange = new core_1.EventEmitter();
    }
    ngAfterViewInit() {
        setTimeout(() => this.initialize());
    }
    initialize() {
        this.canvas = this.canvasRef.nativeElement;
        if (this.canvas.getContext) {
            this.context = this.canvas.getContext('2d');
            this.loadImage(this.image);
        }
    }
    loadImage(image) {
        if (!this.canvas || !image)
            return;
        this.canvas.width = image.width;
        this.canvas.height = image.height;
        this.onresize();
        if (this.zoomLevel == undefined)
            this.zoomLevel = 0;
        if (this.minZoom == undefined)
            this.minZoom = 0;
        if (!this.centerX && !this.centerY) {
            this.setCenterX(this.image.width / 2, false);
            this.setCenterY(this.image.height / 2, false);
        }
        else {
            if (!this.centerX && this.centerX != 0)
                this.setCenterX(this.image.width / 2, false);
            if (!this.centerY && this.centerY != 0)
                this.setCenterY(this.image.height / 2, false);
        }
        this.draw({ x: this.centerX, y: this.centerY }, 1);
        this.rescale(1, this.zoomRatio);
    }
    draw(center, zoomRatio) {
        if (this.context) {
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.context.drawImage(this.image, 0, 0, this.image.width, this.image.height, this.image.width / 2 - center.x * zoomRatio, this.image.height / 2 - center.y * zoomRatio, this.image.width * zoomRatio, this.image.height * zoomRatio);
        }
    }
    get image() {
        return this.imageValue;
    }
    set image(val) {
        this.imageValue = val;
        val.onload = () => {
            this.loadImage(val);
        };
    }
    get top() {
        return this.topValue;
    }
    set top(val) {
        this.topValue = val;
        this.topChange.emit(val);
    }
    get bottom() {
        return this.bottomValue;
    }
    set bottom(val) {
        this.bottomValue = val;
        this.bottomChange.emit(val);
    }
    get left() {
        return this.leftValue;
    }
    set left(val) {
        this.leftValue = val;
        this.leftChange.emit(val);
    }
    get right() {
        return this.rightValue;
    }
    set right(val) {
        this.rightValue = val;
        this.rightChange.emit(val);
    }
    get zoomLevel() {
        return this.zoomLevelValue;
    }
    set zoomLevel(val) {
        val = this.clampZoomLevel(val);
        var newZoomRatio = Math.pow(2, val);
        var previousZoomRatio = this.zoomRatio;
        if (this.context)
            setTimeout(() => this.rescale(previousZoomRatio == undefined ? 1 : previousZoomRatio, newZoomRatio));
        this.zoomLevelValue = val;
        this.zoomRatio = newZoomRatio;
        this.zoomLevelChange.emit(val);
    }
    clampZoomLevel(zoomLevel) {
        var clamped = zoomLevel;
        if (this.minZoom != undefined)
            clamped = Math.max(this.minZoom, clamped);
        if (this.maxZoom != undefined)
            clamped = Math.min(this.maxZoom, clamped);
        return clamped;
    }
    get centerX() {
        return this.centerXValue;
    }
    set centerX(val) {
        this.setCenterX(val, true);
    }
    setCenterX(val, redraw) {
        if (val == this.centerXValue)
            return;
        if (this.image)
            val = this.clampCenter(val, this.image.width);
        this.left = val - this.image.width / (2 * this.zoomRatio);
        this.right = val + this.image.width / (2 * this.zoomRatio);
        if (redraw) {
            this.draw({ x: val, y: this.centerYValue }, this.zoomRatio);
        }
        this.centerXValue = val;
        this.centerXChange.emit(val);
    }
    get centerY() {
        return this.centerYValue;
    }
    set centerY(val) {
        this.setCenterY(val, true);
    }
    setCenterY(val, redraw) {
        if (val == this.centerYValue)
            return;
        if (this.image)
            val = this.clampCenter(val, this.image.height);
        this.centerYValue = val;
        this.centerYChange.emit(val);
        this.top = val - this.image.height / (2 * this.zoomRatio);
        this.bottom = val + this.image.height / (2 * this.zoomRatio);
        if (redraw)
            this.draw({ x: this.centerXValue, y: val }, this.zoomRatio);
    }
    clampCenter(val, length) {
        return Math.min(length, Math.max(0, val));
    }
    rescale(previousZoomRatio, newZoomRatio, center) {
        if (previousZoomRatio == newZoomRatio || previousZoomRatio == undefined || newZoomRatio == undefined)
            return;
        if (this.canvas == null)
            return;
        if (center == null)
            center = { x: this.canvas.scrollWidth / 2, y: this.canvas.scrollHeight / 2 };
        var yRatio = center.y / this.canvas.scrollHeight;
        var xRatio = center.x / this.canvas.scrollWidth;
        var prevWidth = this.right - this.left;
        var prevHeight = this.bottom - this.top;
        var scale = previousZoomRatio / newZoomRatio;
        var newWidth = scale * prevWidth;
        var newHeight = scale * prevHeight;
        this.left = this.leftValue + (prevWidth - newWidth) * xRatio;
        this.right -= (prevWidth - newWidth) * (1 - xRatio);
        this.top = this.topValue + (prevHeight - newHeight) * yRatio;
        this.bottom -= (prevHeight - newHeight) * (1 - yRatio);
        this.centerXValue = (this.left + this.right) / 2;
        this.centerYValue = (this.top + this.bottom) / 2;
        this.centerXChange.emit(this.centerXValue);
        this.centerYChange.emit(this.centerYValue);
        this.draw({ x: this.centerX, y: this.centerY }, newZoomRatio);
    }
    mousedown(event) {
        this.dragPos = { x: event.offsetX, y: event.offsetY };
    }
    mousemove(event) {
        if (event.buttons > 0) {
            if (this.dragPos == null)
                this.dragPos = { x: event.offsetX, y: event.offsetY };
            var dx = (event.offsetX - this.dragPos.x) / this.zoomRatio;
            var dy = (event.offsetY - this.dragPos.y) / this.zoomRatio;
            var centerXVal = this.centerXValue - dx;
            this.setCenterX(centerXVal, false);
            this.setCenterY(this.centerYValue - dy, false);
            this.dragPos = { x: event.offsetX, y: event.offsetY };
            this.draw({ x: this.centerXValue, y: this.centerYValue }, this.zoomRatio);
        }
    }
    mousewheel(event) {
        event.preventDefault();
        var previousZoomLevel = this.zoomLevelValue;
        var previousZoomRatio = this.zoomRatio;
        var newZoomLevel = this.clampZoomLevel(previousZoomLevel + event.deltaY * 0.05);
        var newZoomRatio = Math.pow(2, newZoomLevel);
        this.rescale(previousZoomRatio, newZoomRatio, { x: event.offsetX, y: event.offsetY });
        this.zoomLevelValue = newZoomLevel;
        this.zoomRatio = newZoomRatio;
        this.zoomLevelChange.emit(newZoomLevel);
    }
    onresize() {
        this.canvasWidthChange.emit(this.canvas.scrollWidth);
        this.canvasHeightChange.emit(this.canvas.scrollHeight);
    }
}
ZoomableCanvasComponent.decorators = [
    { type: core_1.Component, args: [{
                selector: 'zoomable-canvas',
                template: `<canvas #canvas
        (mousedown)="mousedown($event)" (mousemove)="mousemove($event);"
        (mousewheel)="mousewheel($event)"
        (window:resize)="onresize()"
        style="width: 100%; height: 100%"
        ></canvas>`
            },] },
];
ZoomableCanvasComponent.ctorParameters = () => [];
ZoomableCanvasComponent.propDecorators = {
    'canvasRef': [{ type: core_1.ViewChild, args: ["canvas",] },],
    'maxZoom': [{ type: core_1.Input },],
    'minZoom': [{ type: core_1.Input },],
    'imgSrc': [{ type: core_1.Input },],
    'topChange': [{ type: core_1.Output },],
    'bottomChange': [{ type: core_1.Output },],
    'leftChange': [{ type: core_1.Output },],
    'rightChange': [{ type: core_1.Output },],
    'zoomLevelChange': [{ type: core_1.Output },],
    'centerXChange': [{ type: core_1.Output },],
    'centerYChange': [{ type: core_1.Output },],
    'canvasWidthChange': [{ type: core_1.Output },],
    'canvasHeightChange': [{ type: core_1.Output },],
    'image': [{ type: core_1.Input },],
    'zoomLevel': [{ type: core_1.Input },],
    'centerX': [{ type: core_1.Input },],
    'centerY': [{ type: core_1.Input },],
};
exports.ZoomableCanvasComponent = ZoomableCanvasComponent;
//# sourceMappingURL=zoomablecanvas.component.js.map